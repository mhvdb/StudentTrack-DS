<!DOCTYPE html>
<html>
  <head>
    <title>Info Support Data Science eXperience</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	
	<script type="text/javascript" src="../etc/jquery-1.5.2.js"></script>
		
	<style type="text/css">
	.container.collapsed{
		/*background-color:red;
		height: 88px;
		margin-bottom: 10px;
		margin-right: 10px;
		width: 427px;*/
	}
	
	.container.expanded{
		/*background-color:green;
		height: 300px;
		margin-bottom: 10px;
		margin-right: 10px;
		width: 427px;*/
	}
	
	.expanded_content {
		display: none;
	}
	
	.container.expanded .expanded_content {
		display: block;
	}
	.container.expanded .collapsed_content {
		display: none;
	}
	.expanded_content{
		/* height:100px; */
		color: darkgrey;
		display: none;
	}
	
	/*default state*/
	.container.collapsed .nav {
		/*height:20px;
		width:20px;
		background-color: black;
		color:white;*/
		/*background-image: url("../etc/toggle_expand_alt.png");
		background-repeat: no-repeat;*/
		background: url("../etc/toggle_expand_alt.png") no-repeat;
		background-size: 30px 30px;
	}
	
	.container.expanded .nav {
		/*height:20px;
		width:20px;
		background-color: white;
		color:black;   */
		background: url("../etc/toggle_collapse_alt.png") no-repeat;
		background-size: 30px 30px;
	}
	</style>
	
    <style type="text/css">
      /*@import url(../etc/fonts.css);*/
	  
	  @font-face {
	    font-family: 'Yanone Kaffeesatz';
	    font-style: normal;
	    font-weight: 400;
		src: local('Yanone Kaffeesatz Regular'), local('YanoneKaffeesatz-Regular'), url(../etc/YDAoLskQQ5MOAgvHUQCcLaGiwYDZumYWHCJeOGLK6bU.woff2) format('woff2'), url(../etc/YDAoLskQQ5MOAgvHUQCcLcvyhSUCWNe0YoQkk3OBepg.woff) format('woff');
  	  }

      /*@import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);*/
	  
	  @font-face {
	    font-family: 'Droid Serif';
	    font-style: normal;
	    font-weight: 400;
	    src: local('Droid Serif'), local('DroidSerif'), url(../etc/0AKsP294HTD-nvJgucYTaI4P5ICox8Kq3LLUNMylGO4.woff2) format('woff2'), url(../etc/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff) format('woff');
	  }
	  @font-face {
	    font-family: 'Droid Serif';
	    font-style: normal;
	    font-weight: 700;
	    src: local('Droid Serif Bold'), local('DroidSerif-Bold'), url(../etc/QQt14e8dY39u-eYBZmppwYlIZu-HDpmDIZMigmsroc4.woff2) format('woff2'), url(../etc/QQt14e8dY39u-eYBZmppwTqR_3kx9_hJXbbyU8S6IN0.woff) format('woff');
	  }
	  @font-face {
	    font-family: 'Droid Serif';
	    font-style: italic;
	    font-weight: 400;
	    src: local('Droid Serif Italic'), local('DroidSerif-Italic'), url(../etc/cj2hUnSRBhwmSPr9kS5898u2Q0OS-KeTAWjgkS85mDg.woff2) format('woff2'), url(../etc/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff) format('woff');
	  }
	  
      /*@import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);*/
	  
	  /* cyrillic-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../etc/ViZhet7Ak-LRXZMXzuAfkbWJ8El2VFcUWHOh_Oq6BA8.woff2) format('woff2'), url(../etc/ViZhet7Ak-LRXZMXzuAfkSfE9Gpc2xZQgtwyMvPhThE.woff) format('woff');
        unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
      }
      /* cyrillic */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../etc/ViZhet7Ak-LRXZMXzuAfkRLwxQbNcFnuWuPk3YnjToI.woff2) format('woff2'), url(../etc/ViZhet7Ak-LRXZMXzuAfkWOb2gHztoQeulij-1lvl-8.woff) format('woff');
        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }
      /* greek-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../etc/ViZhet7Ak-LRXZMXzuAfkXZwgMdXZ_smNJnor9b37uA.woff2) format('woff2'), url(../etc/ViZhet7Ak-LRXZMXzuAfkbUY-ErTxhuJNpt9lU8fcqw.woff) format('woff');
        unicode-range: U+1F00-1FFF;
      }
      /* greek */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../etc/ViZhet7Ak-LRXZMXzuAfkVvp_UfalQ96C-39B62FvR4.woff2) format('woff2'), url(../etc/ViZhet7Ak-LRXZMXzuAfkX6qoo8ILXpvSLO10ucU3yI.woff) format('woff');
        unicode-range: U+0370-03FF;
      }
      /* latin-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../etc/ViZhet7Ak-LRXZMXzuAfkag5eI2G47JWe0-AuFtD150.woff2) format('woff2'), url(../etc/ViZhet7Ak-LRXZMXzuAfkdIh4imgI8P11RFo6YPCPC0.woff) format('woff');
        unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
      }
      /* latin */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../etc/ViZhet7Ak-LRXZMXzuAfkY4P5ICox8Kq3LLUNMylGO4.woff2) format('woff2'), url(../etc/ViZhet7Ak-LRXZMXzuAfkYbN6UDyHWBl620a-IRfuBk.woff) format('woff');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      /* cyrillic-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../etc/ceqTZGKHipo8pJj4molytrLZkzWHE0Rai0z0KZwCYHE.woff2) format('woff2'), url(../etc/ceqTZGKHipo8pJj4molytjpEpsbGv0WCalYSBSSLSDI.woff) format('woff');
        unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
      }
      /* cyrillic */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../etc/ceqTZGKHipo8pJj4molytqs1twL42OQU-XDphSlMXYM.woff2) format('woff2'), url(../etc/ceqTZGKHipo8pJj4molytlRROVH9Vvc8xHnAGvvgPQc.woff) format('woff');
        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }
      /* greek-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../etc/ceqTZGKHipo8pJj4molytuGaZ6kaGPxTsxBG85inVYY.woff2) format('woff2'), url(../etc/ceqTZGKHipo8pJj4molytkxkyJNiPQcjp3dyBORqq9o.woff) format('woff');
        unicode-range: U+1F00-1FFF;
      }
      /* greek */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../etc/ceqTZGKHipo8pJj4molytpGgvICTqEy5bPQVoK8tr-Y.woff2) format('woff2'), url(../etc/ceqTZGKHipo8pJj4molytuSd7Sk-1zCox9FpyOEBNq8.woff) format('woff');
        unicode-range: U+0370-03FF;
      }
      /* latin-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../etc/ceqTZGKHipo8pJj4molytqsA81DAeuqoeYxDcSOJPMY.woff2) format('woff2'), url(../etc/ceqTZGKHipo8pJj4molytoUt79146ZFaIJxILcpzmhI.woff) format('woff');
        unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
      }
      /* latin */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../etc/ceqTZGKHipo8pJj4molytolIZu-HDpmDIZMigmsroc4.woff2) format('woff2'), url(../etc/ceqTZGKHipo8pJj4molytjqR_3kx9_hJXbbyU8S6IN0.woff) format('woff');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      /* cyrillic-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: italic;
        font-weight: 400;
        src: local('Ubuntu Mono Italic'), local('UbuntuMono-Italic'), url(../etc/KAKuHXAHZOeECOWAHsRKA-S36XEWCHkcB1lVV5U7Zv8.woff2) format('woff2'), url(../etc/KAKuHXAHZOeECOWAHsRKAyk_NprmDuTMe6ZNb2XT6F0.woff) format('woff');
        unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
      }
      /* cyrillic */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: italic;
        font-weight: 400;
        src: local('Ubuntu Mono Italic'), local('UbuntuMono-Italic'), url(../etc/KAKuHXAHZOeECOWAHsRKA-Z7HcNP3hh35ENBlkfUajE.woff2) format('woff2'), url(../etc/KAKuHXAHZOeECOWAHsRKA1qQwgjTnk_Nvsyjd7gmcn8.woff) format('woff');
        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }
      /* greek-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: italic;
        font-weight: 400;
        src: local('Ubuntu Mono Italic'), local('UbuntuMono-Italic'), url(../etc/KAKuHXAHZOeECOWAHsRKA4BrlVs03822P1mxoSnc7KY.woff2) format('woff2'), url(../etc/KAKuHXAHZOeECOWAHsRKA_XGQ2zFklq0BS5_Iep93MM.woff) format('woff');
        unicode-range: U+1F00-1FFF;
      }
      /* greek */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: italic;
        font-weight: 400;
        src: local('Ubuntu Mono Italic'), local('UbuntuMono-Italic'), url(../etc/KAKuHXAHZOeECOWAHsRKA-JGFIOmtGeg8fQPdN29h_E.woff2) format('woff2'), url(../etc/KAKuHXAHZOeECOWAHsRKAxXa1O80pZ7GLXQpBwNdkLA.woff) format('woff');
        unicode-range: U+0370-03FF;
      }
      /* latin-ext */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: italic;
        font-weight: 400;
        src: local('Ubuntu Mono Italic'), local('UbuntuMono-Italic'), url(../etc/KAKuHXAHZOeECOWAHsRKA5A-et8bj3Rpvmq6f0RSK8U.woff2) format('woff2'), url(../etc/KAKuHXAHZOeECOWAHsRKAyiURDTH4ZeuJyFQH0IObys.woff) format('woff');
        unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
      }
      /* latin */
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: italic;
        font-weight: 400;
        src: local('Ubuntu Mono Italic'), local('UbuntuMono-Italic'), url(../etc/KAKuHXAHZOeECOWAHsRKA8u2Q0OS-KeTAWjgkS85mDg.woff2) format('woff2'), url(../etc/KAKuHXAHZOeECOWAHsRKA9kZXW4sYc4BjuAIFc1SXII.woff) format('woff');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
	  
	  

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 25%;
        height: 92%;
        float: left;
        text-align: center;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
      }

      .subtle {
        color: #777;
      }

      li {
        margin: 1em 0;
      }

      .pageref {
        position: absolute;
        bottom: 12px;
        left: 50%;
        color: #777;
        
      }
      .pageref:before {
        content: "p. ";
        color: #777;
      }
   
      h1 {
        color: #00539f;
      }

      img[src='../etc/IS Logo.png'] {
        position: absolute;
        bottom: 10px;
	left: 10px;
      }

      .square {
        position: absolute;
        right: 0;
        bottom: 0;
        width:15px;
        height: 75%;
        background-color: #0065A7;
      }

      .square_upper {
        position: absolute;
        right: 0;
        bottom: 75%;
        width:15px;
        height: 100px;
        background-color: #007bbf;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: middle, left
name: section
layout: true
---
class: middle, left
name: lab
layout: true
{{ content }}
# LAB 
---
class: top, left
name: default
layout: true
![Info Support b.v.](../etc/IS Logo.png)
.square[]
.square_upper[]

---
class: center, middle
# Info Support Data Science eXperience
Lab 4 - Datavisualisatie met R
---
# Introductie Sentiment Analyse
Twitter is een typische databron waar data  minder gestructureerd wordt opgeslagen dan in de meeste relationele databases.
Het ontdekken van patronen in tweets is daarmee een stuk minder 'exact' dan het ontdekken van patronen in een tabel met fietsverhuur-data.

In deze oefening kijken we hoe we meer inzicht kunnen krijgen in Twitter-data met behulp van datavisualisaties.

Om te beginnen open je in R Studio via File -> Open File... het bestand `C:\Users\student\Desktop\labs\3 - Datavisualisatie\R\Lab04_Start.R`.
Als het bestand geopend is, selecteer je alle tekst in het bestand en klik je op de knop 'Run'. Nu zijn de juiste *libraries* geladen, en zijn enkele functies aangemaakt.
 
---
# 1.0 Data inlezen
Eerst moeten we de dataset inlezen. De data in bestand "tweets_by_keyword.csv" is klaar om in te lezen zonder verdere bewerkingen.
Hint: gebruik de functie read.csv()

.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Probeer eerst zelf de dataset in te lezen. Kom je er niet uit? Klik dan hier om de code te tonen.
]
.expanded_content[
```R
lab.tweets <- read.csv('tweets_by_keyword.csv');
```
]
.collapsed_content[
```R
         <- read.csv(                             );
```
]]]

---
# 1.1 Verkennen van de dataset
Om een idee te krijgen hoe de dataset eruit ziet, vragen we de kolomnamen en de eerste 6 rijen van de dataset op.
.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Probeer het eerst zelf uit te vinden. Kom je er niet uit? Klik dan hier om de code te tonen.
]
.expanded_content[
```R
colnames(lab.tweets)
head(lab.tweets)
```
]
.collapsed_content[
```R
colnames
head
```
]]]

Bekijk ook de tekst van de tweets.
```R
lab.tweets$text
```

Zoals te zien bevatten de tweets diverse overbodige karakters, URL's en afkortingen. Deze zijn niet relevant voor onze lab, dus gaan we de tekst opschonen.
---
# 1.2 Opschonen van de tweet tekst
Om de tekst te ontdoen van onnodige elementen zijn een aantal opschoonacties nodig. 
Voor het gemak hebben we hier een functie voor gemaakt. Wanneer je de naam van de functie invoert in R krijg je de inhoud te zien:
```R
clean.text
```
De invulling hiervan kun je zien in het bestand `Lab04_Start.R`, dat je reeds geopend en uitgevoerd hebt. 

Probeer nu met één commando de tekst op te schonen en op te slaan in lab.text.
.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Probeer het eerst zelf uit te vinden. Kom je er niet uit? Klik dan hier om de code te tonen.
]
.expanded_content[
```R
lab.text = clean.text(lab.tweets$text)
```
]
.collapsed_content[
```R
lab.text = 
```
]]]
---

# 1.3 Controleren van de tweet tekst
Bekijk de eerste regels van zowel de originele als de aangepaste tekst om te zien wat er is gewijzigd.
.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]
.expanded_content[
```R
head(lab.tweets$text)
head(lab.text)
```
]
.collapsed_content[
```R

```
]]]
---
# 2.0 Wordcloud (1/2)
De tweet tekst is nu opgeschoond. Om inzicht te krijgen in de onderwerpen waar over getwitterd wordt, plotten we een wordcloud.

Om de tekst te kunnen plotten, moet deze eerst omgezet worden naar een *term document matrix*\*.

```R
# Maak de corpus
ap.corpus <- VCorpus(VectorSource(lab.text))

# Verwijder stopwoorden
ap.corpus <- tm_map(ap.corpus, function(x) removeWords(x, stopwords("english")))
ap.corpus <- tm_map(ap.corpus, PlainTextDocument)

# Maak de term document matrix
ap.tdm <- TermDocumentMatrix(ap.corpus)

# Converteer naar een matrix
ap.m <- as.matrix(ap.tdm)
ap.v <- sort(rowSums(ap.m),decreasing=TRUE)
ap.d <- data.frame(word = names(ap.v),freq=ap.v)
```

<sub>**\(Wat een term document matrix exact inhoudt valt buiten de scope van deze lab, maar het is voldoende om te weten dat dit nodig is om een wordcloud te maken.)*</sub>

---
# 2.1 Wordcloud (2/2)
Nu de *term document matrix* gevuld is, kunnen we deze gebruiken om een wordcloud te plotten.

```R
pal2 <- brewer.pal(8,"Dark2")

wordcloud(ap.d$word,ap.d$freq, scale=c(4.5,.5),min.freq=3,
          max.words=Inf, random.order=FALSE, rot.per=.15, colors=pal2)
```

Bekijk de wordcloud. De grootte van een woord wordt bepaald door de frequentie waarin deze voorkomt. Wat valt je op?

.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]
.expanded_content[
```
Het woord 'Kickstarter' is vrij dominant aanwezig.
Dit is ook logisch, omdat dit woord in iedere tweet voorkomt.
Daarnaast is eenvoudig te zien welke worden veel gebruikt worden,
maar is niet direct duidelijk of dit positief of negatief is.
```
]
.collapsed_content[
```

```
]]]

---
# 3.0 Sentiment woordenboeken inlezen
We willen van de ingelezen tweets gaan bepalen wat het sentiment is. Is men positief of negatief?
Hier zijn verschillende technieken voor, van online webservices tot offline woordenboeken. Wij gaan werken met woordenboeken die positieve en negatieve woorden bevatten.
```R
hu.liu.pos = scan('positive-words.txt', what='character', comment.char=';')
hu.liu.neg = scan('negative-words.txt', what='character', comment.char=';')
```
Bekijk de eerste 100 regels van beide woordenboeken om een idee te krijgen van woorden die gebruikt worden om het sentiment van een tweet te bepalen.
```R
head(hu.liu.pos, 100)
head(hu.liu.neg, 100)
```
Op basis van deze woorden gaan we proberen vast te stellen of een tweet positief of negatief gestemd is.
---
# 3.1 Het scoren van de tweets (1/2)
Nu we de tekst uit de tweets hebben opgeschoond en de woordenboeken hebben ingelezen, kunnen we de woorden uit de tweets gaan beoordelen aan de hand van aanwezige positieve en negatieve woorden.
Hiervoor is een functie gemaakt:
```R
score.sentiment
```

Nu gaan we voor onze tweets de score bepalen.
```R
lab.scores = score.sentiment(lab.text, hu.liu.pos,
                             hu.liu.neg, .progress='text')
```
De score van de tweets staat nu per tweet opgeslagen als een numerieke waarde (-4 t/m 4). Wanneer je de eerste regels van `lab.scores` bekijkt, zie je hoe dit opgeslagen is.

---
# 3.2 Het scoren van de tweets (2/2)
Om de leesbaarheid te verhogen willen we de volgende labels toevoegen aan de data:

<table>
	<tr>
		<td>Label</td>
		<td align="right">Score</td>
	</tr>
	<tr>
		<td>Extreem negatief</td>
		<td align="right">-4</td>
	</tr>
	<tr>
		<td>Zeer negatief</td>
		<td align="right">-3</td>
	</tr>
	<tr>
		<td>Negatief</td>
		<td align="right">-2</td>
	</tr>
	<tr>
		<td>Matig negatief</td>
		<td align="right">-1</td>
	</tr>
	<tr>
		<td>Neutraal</td>
		<td align="right">0</td>
	</tr>
	<tr>
		<td>Matig positief</td>
		<td align="right">1</td>
	</tr>
	<tr>
		<td>Positief</td>
		<td align="right">2</td>
	</tr>
	<tr>
		<td>Zeer positief</td>
		<td align="right">3</td>
	</tr>
	<tr>
		<td>Extreem positief</td>
		<td align="right">4</td>
	</tr>
</table>

We stoppen deze labels in een dataframe. Vervolgens wijzen we de juiste labels toe aan de scores.

```R
score <- data.frame(score = c(1,2,3,4,5,6,7,8,9), score_label =
c("Extreem negatief","Zeer negatief","Negatief","Matig negatief","Neutraal",
"Matig positief","Positief","Zeer positief","Extreem positief"))
lab.scores$score_label <- score$score_label[lab.scores$score+5]
```
---
# 3.3 Plot het sentiment

Maak nu een barchart waarin het label van de score (kolom `score_label` uit de dataset `lab.scores`) wordt uitgezet tegen het aantal tweets. Hieruit wordt direct zichtbaar wat het gemiddelde sentiment is.

.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Voor een basisgrafiek staat de code hieronder uitgewerkt. Probeer zelf de grafiek duidelijker te maken door bijv. kleur, volgorde of titels toe te voegen.
]
.expanded_content[
```R
ggplot(lab.scores, aes(x=score_label)) +
  geom_bar(aes(y=..count.., x=reorder(score_label, score), fill=score_label)) +
  scale_fill_brewer(palette="Set2",name="Sentiment") +
  labs(x="Sentiment", y="Aantal tweets") +
  ggtitle("Sentiment analyse van tweets over Kickstarter") +
  theme(plot.title=element_text(size=25))```
]
.collapsed_content[
```R
ggplot(lab.scores, aes(x=score_label)) + geom_bar()
```
]]]
---
# 4.0 Comparison word cloud (1/3)
In een word cloud wordt de plaatsing tot nu toe random gedaan. We zouden echter de positie van woorden kunnen relateren aan de emotie. Dit zou ons in één blik inzicht geven in zowel de onderwerpen als de bijbehorende emoties.

Om dat te doen, beginnen we met het splitsen van de woorden op basis van sentiment.

```R
# Splits de tekst op basis van emotie.
emos = levels(factor(lab.scores$score_label))
nemo = length(emos)
emo.docs = rep("", nemo)
head(emo.docs)
for (i in 1:nemo)
{
  tmp = lab.text[lab.scores$score_label == emos[i]]
  emo.docs[i] = paste(tmp, collapse=" ")
}
```
---
# 4.1 Comparison word cloud (2/3)
We zetten de resultaten opnieuw om naar een *term document matrix* (die nodig is om een word cloud te plotten).

```R
# Verwijder de stopwoorden
emo.docs = removeWords(emo.docs, stopwords("english"))
# Maak de corpus
corpus = VCorpus(VectorSource(emo.docs))
tdm = TermDocumentMatrix(corpus)
tdm = as.matrix(tdm)
colnames(tdm) = emos
```
---
# 4.2 Comparison word cloud (3/3)
Ten slotte voegen we de resultaten samen en plotten we de comparison cloud.
```R
# Wis de huidige plots.
dev.off()

# Stel de achtergrondkleur in op donkergrijs.
par(bg="gray15")

# Plot de comparison word cloud
comparison.cloud(tdm, colors = brewer.pal(nemo, "Dark2"),
                 scale = c(3,.5), random.order = FALSE, title.size = 1.5)
```
In de vorige word cloud was het woord *kickstarter* erg groot. Kun je het woord kickstarter in deze grafiek terugvinden?

.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kun je bedenken hoe de grootte van een woord in deze nieuwe grafiek bepaald wordt?
]
.expanded_content[
Hoe groter de woorden zijn in deze word cloud, hoe sterker ze een éénduidige waarde hebben. 'kickstarter' wordt dus zowel negatief als positief gebruikt en is dus klein weergegeven, terwijl bijvoorbeeld 'enemies' bijna enkel negatief gebruikt wordt en daarom groot weergegeven is.
]
.collapsed_content[
]]]

---
# Introductie Retweet Analyse

Veel van het berichtenverkeer op Twitter wordt bepaald door *retweets*. Bij een *retweet* kopieert een Twitter-gebruiker de *tweet* van een andere gebruiker. 
Retweets kunnen veel aangeven over hoe invloedrijk een Twitter-gebruiker is (veel retweets = veel invloed). In dit onderdeel duiken we wat dieper de retweets in, om ook hier met behulp van visualisaties inzicht te verkrijgen.
---
# 5.0 Data inlezen
Eerst moeten we de dataset inlezen. De data in bestand "tweets_by_timeline.csv" staat klaar om ingelezen te worden.
Hint: gebruik de functie read.csv()

.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Probeer eerst zelf de dataset in te lezen. Kom je er niet uit? Klik dan hier om de code te tonen.
]
.expanded_content[
```R
lab.tweets <- read.csv('tweets_by_timeline.csv');
```
]
.collapsed_content[
```R
           <- read.csv(                        );
```
]]]
---
# 5.1 Bekijk de data
Bekijk de bovenste regels van de zojuist ingelezen dataset. Het zijn tweets allemaal afkomstig van 1 persoon.

```R
head(lab.tweets)
```

.box[
.container.collapsed[
.nav.closed[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We willen wat meer inzicht in het aantal retweets van deze persoon. Probeer onderstaande code te verbeteren, zodat beide waarden een eigen kleur krijgen.
]
.expanded_content[
```R
ggplot(data=lab.tweets,aes(x=isRetweet, fill=isRetweet)) + geom_bar()

```
]
.collapsed_content[
```R
ggplot(data=lab.tweets,aes(x=isRetweet)) + geom_bar()
```
]]]
---
# 5.2 Retweets identificeren
Alleen retweets die via het knopje 'retweet' op Twitter verzonden zijn, worden in de kolom 'isRetweet' als dusdanig aangemerkt.
Het komt echter regelmatig voor dat de inhoud van een tweet door een gebruiker wordt gekopieerd om er bijvoorbeeld een extra hashtag aan toe te voegen. In dat geval staat er 'via' of 'RT' voor de tweet.

Met het commando 'grep' kunnen we op basis van een formule/expressie ook deze tweets herkennen.

```R
# Selecteer alleen de retweets
rt_patterns = grep("(RT|via)((?:\\b\\W*@\\w+)+)",
                   lab.tweets$text, ignore.case=TRUE)
```

Selecteer uit de verzameling van alle tweets nu zowel de zojuist gevonden retweets als de retweets waarvan Twitter aangeeft dat het retweets zijn.

```R
rt_patterns <- lab.tweets$text[rt_patterns || lab.tweets$isRetweet]
```

---
# 5.3 (Re)tweeters selecteren
We maken een twee (lege) lijsten, een voor de posters van de tweets en een voor de retweeters.
```R
who_retweet = as.list(1:length(rt_patterns))
who_post = as.list(1:length(rt_patterns))
```
Vervolgens gaan we de lijsten vullen met de juiste waarden.
```R
for (i in 1:length(rt_patterns))
{
  # selecteer de retweet
  index=rt_patterns[i]
  twit = lab.tweets[index,]
  # selecteer de originele poster van de tweet
  poster = str_extract_all(twit$text,"(RT|via)((?:\\b\\W*@\\w+)+)")
  # verwijder ':'
  poster = gsub(":", "", unlist(poster))
  # naam van de retweeted user
  who_post[[i]] = gsub("(RT @|via @)", "", poster, ignore.case=TRUE)
  # naam van de retweeting user
  screenName = gsub(":","",unlist(twit$screenName))
  who_retweet[[i]] = rep(screenName, length(poster))
}
```
---
# 5.4 Poster en retweeters combineren
We vertalen beide lijsten naar een vector en vervolgens combineren we ze naar 1 dataframe.
```R
who_post = unlist(who_post)
who_retweet = unlist(who_retweet)

retweeter_poster = cbind(who_retweet, who_post)
```
Het resultaat is een dataframe met twee kolommen, de poster en de retweeter.
```R
retweeter_poster
```
---
# 5.5 Resultaten modelleren
We willen de relaties tussen de retweeters en posters weergeven. We kunnen dit realiseren door gebruik te maken van een edgelist.
```R
rt_graph = graph.edgelist(retweeter_poster)

# selecteer de namen van de retweeters als label.
ver_labs = get.vertex.attribute(rt_graph, "name", index=V(rt_graph))
```
Om te voorkomen dat de visualisatie onleesbaar wordt, maken we gebruik van het *fruchterman-reingold* algoritme, dat voor een gunstige spreiding van de weergegeven punten zorgt.
```R
glay = layout.fruchterman.reingold(rt_graph)
```
---
# 5.6 Resultaten plotten
En tenslotte plotten we de resultaten.
```R
dev.off()
par(bg="gray15", mar=c(1,1,1,1))
plot(rt_graph, layout=glay,
     vertex.color="gray25",
     vertex.size=10,
     vertex.label=ver_labs,
     vertex.label.family="sans",
     vertex.shape="none",
     vertex.label.color=hsv(h=0, s=0, v=.95, alpha=0.5),
     vertex.label.cex=0.85,
     edge.arrow.size=0.8,
     edge.arrow.width=0.8,
     edge.width=3,
     edge.color=hsv(h=.95, s=1, v=.7, alpha=0.5))

title("\nWie wordt geretweet door Jen Stirrup?",
      cex.main=1, col.main="gray95")
```
---
# 6.0 Tot slot..

In de laatste plot is visueel weergegeven wie er geretweet wordt.
Als een persoon vaker geretweet wordt, dan resulteert dit ook in meerdere lijnen naar die persoon. 
Het patroon dat hierdoor ontstaat geeft direct inzicht in het retweetgedrag van de gebruiker.
</textarea>
	
	
	
    <!--<script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
    </script>-->
	<script src="../etc/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      //var slideshow = remark.create();
		var slideshow = remark.create({
		  // Set the slideshow display ratio
		  // Default: '4:3'
		  // Alternatives: '16:9', ...
		  ratio: '16:9',

		  // Navigation options
		  navigation: {
			// Enable or disable navigating using scroll
			// Default: true
			// Alternatives: false
			scroll: true,

			// Enable or disable navigation using touch
			// Default: true
			// Alternatives: false
			touch: true,

			// Enable or disable navigation using click
			// Default: false
			// Alternatives: true
			click: false
		  }
});
    </script>
	
	<script type="text/javascript">
    $(".box").delegate(".nav.closed", "click", function(e) {
        //if ($(e.target).hasClass("container")) {
            $(this).parent().addClass("expanded");
        //}
    });
  
    $(".box").delegate(".container.expanded .nav", "click", function(e) {
        $(this).parent().removeClass("expanded");
        e.stopPropagation();
    });
	</script>
	
  </body>
</html>